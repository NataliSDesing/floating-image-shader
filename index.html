<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Floating Image Shader</title>
    <style>
      html, body {
        margin: 0;
        height: 200vh; /* нужно для скролла */
        background: transparent;
        overflow-x: hidden;
      }

      #shader-container {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 100vw;
        height: 100vh;
        pointer-events: none;
        z-index: -1;
      }

      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <div id="shader-container"></div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>

    <script>
      const container = document.getElementById("shader-container");
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
      camera.position.z = 3.2;

      const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      container.appendChild(renderer.domElement);

      const loader = new THREE.TextureLoader();
      const imageUrl = 'c66cc9bf-2d9b-49b1-97ed-b443fd686ea6.png'; // добавь сюда путь к нужной картинке

      loader.load(imageUrl, texture => {
        const imgRatio = texture.image.width / texture.image.height;
        const height = 1.8;
        const width = height * imgRatio;

        const geometry = new THREE.PlaneGeometry(width, height, 40, 40);
        const material = new THREE.ShaderMaterial({
          uniforms: {
            time: { value: 0 },
            texture1: { value: texture }
          },
          vertexShader: `
            uniform float time;
            varying vec2 vUv;
            varying float vWave;

            void main() {
              vUv = uv;
              vec3 pos = position;
              float wave = sin(pos.y * 6.0 + time * 2.0) * 0.06;
              pos.z += wave;
              vWave = wave;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
          `,
          fragmentShader: `
            uniform sampler2D texture1;
            varying vec2 vUv;
            varying float vWave;

            void main() {
              float light = 0.5 + vWave * 3.0;
              vec4 tex = texture2D(texture1, vUv);
              gl_FragColor = vec4(tex.rgb * light, tex.a);
            }
          `,
          transparent: true
        });

        const mesh = new THREE.Mesh(geometry, material);
        scene.add(mesh);

        mesh.rotation.y = 0.3; // начальный наклон вбок
        mesh.rotation.x = -0.1; // чуть наклонен вниз
        mesh.position.x = 0;

        // scroll-related setup
        let scrollY = 0;
        window.addEventListener('scroll', () => {
          scrollY = window.scrollY / window.innerHeight;
        });

        const animate = () => {
          requestAnimationFrame(animate);
          material.uniforms.time.value += 0.01;

          // реакция на скролл
          camera.position.z = 3.2 - Math.min(scrollY * 0.8, 0.8); // приближение
          mesh.rotation.y = 0.3 - Math.min(scrollY * 0.3, 0.3);   // выравнивание по Y
          mesh.rotation.x = -0.1 + Math.min(scrollY * 0.2, 0.1);  // чуть выпрямляется по X
          mesh.position.x = scrollY * 0.4; // вбок

          renderer.render(scene, camera);
        };

        animate();
      });

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Floating Image Shader</title>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background: transparent;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r148/three.min.js"></script>
    <script>
      const urlParams = new URLSearchParams(window.location.search);
      const imageParam = urlParams.get("img") || "default.jpg";
      const imageUrl = imageParam.startsWith("http") ? imageParam : `./images/${imageParam}`;

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.z = 4;

      const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      const loader = new THREE.TextureLoader();
      loader.crossOrigin = "anonymous";
      loader.load(imageUrl, texture => {
        const imgRatio = texture.image.width / texture.image.height;
        const height = 2;
        const width = height * imgRatio;

        const geometry = new THREE.PlaneGeometry(width, height, 40, 40);

        const material = new THREE.ShaderMaterial({
          uniforms: {
            time: { value: 0 },
            texture1: { value: texture },
            lightPos: { value: new THREE.Vector3(-1.0, 1.0, 1.0) },
          },
          vertexShader: `
            uniform float time;
            varying vec2 vUv;
            varying vec3 vNormal;
            varying vec3 vPosition;
            void main() {
              vUv = uv;
              vNormal = normal;
              vec3 pos = position;
              float wave = sin(pos.y * 5.0 + time * 2.0) * 0.1;
              pos.z += wave;
              vPosition = pos;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
          `,
          fragmentShader: `
            uniform sampler2D texture1;
            uniform vec3 lightPos;
            varying vec2 vUv;
            varying vec3 vNormal;
            varying vec3 vPosition;
            void main() {
              vec3 normal = normalize(cross(dFdx(vPosition), dFdy(vPosition)));
              vec3 lightDir = normalize(lightPos - vPosition);
              float light = dot(normal, lightDir);
              light = clamp(light, 0.4, 1.0);
              vec4 tex = texture2D(texture1, vUv);
              gl_FragColor = vec4(tex.rgb * light, tex.a);
            }
          `,
          side: THREE.DoubleSide,
        });

        const mesh = new THREE.Mesh(geometry, material);
        mesh.rotation.y = Math.PI / 10;
        mesh.rotation.z = -Math.PI / 20;
        scene.add(mesh);

        function animate() {
          requestAnimationFrame(animate);
          material.uniforms.time.value += 0.01;
          renderer.render(scene, camera);
        }
        animate();
      });

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>

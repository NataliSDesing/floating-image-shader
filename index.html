<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Floating Image Shader</title>
  <style>
    html, body {
      margin: 0;
      overflow: hidden;
      height: 100%;
      background: transparent; /* âœ… ÐŸÑ€Ð¾Ð·Ñ€Ð°Ñ‡Ð½Ñ‹Ð¹ Ñ„Ð¾Ð½ */
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <!-- âœ… ÐŸÐ¾Ð´ÐºÐ»ÑŽÑ‡Ð°ÐµÐ¼ Three.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // âœ… Ð¡Ñ†ÐµÐ½Ð°, ÐºÐ°Ð¼ÐµÑ€Ð°, Ñ€ÐµÐ½Ð´ÐµÑ€ÐµÑ€ Ñ Ð¿Ñ€Ð¾Ð·Ñ€Ð°Ñ‡Ð½Ð¾ÑÑ‚ÑŒÑŽ
    let scene = new THREE.Scene();
    let camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
    let renderer = new THREE.WebGLRenderer({alpha: true, antialias: true});
    renderer.setClearColor(0x000000, 0); // âœ… ÐŸÑ€Ð¾Ð·Ñ€Ð°Ñ‡Ð½Ñ‹Ð¹ Ñ„Ð¾Ð½
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    camera.position.z = 2.5;

    const loader = new THREE.TextureLoader();
    loader.load(
      // âœ… Ð—Ð°Ð¼ÐµÐ½Ð¸ Ð¿Ñ€Ð¸ Ð½ÐµÐ¾Ð±Ñ…Ð¾Ð´Ð¸Ð¼Ð¾ÑÑ‚Ð¸ ÑÑÑ‹Ð»ÐºÑƒ Ð½Ð° ÑÐ²Ð¾ÑŽ ÐºÐ°Ñ€Ñ‚Ð¸Ð½ÐºÑƒ
      "https://optim.tildacdn.pub/tild3266-3731-4934-a561-363134373638/-/format/webp/eve-NLZcjEWBeyE-unsp.jpg.webp", 
      texture => {
        const geometry = new THREE.PlaneGeometry(2, 2, 40, 40);
        const material = new THREE.ShaderMaterial({
          uniforms: {
            time: { value: 0 },
            mouse: { value: new THREE.Vector2(0.5, 0.5) },
            texture1: { value: texture }
          },
          vertexShader: `
            uniform float time;
            uniform vec2 mouse;
            varying vec2 vUv;

            void main() {
              vUv = uv;
              vec3 pos = position;

              float waveX = sin(pos.y * 5.0 + time * 2.0) * 0.03;
              float waveY = sin(pos.x * 5.0 + time * 2.0) * 0.03;

              pos.z += waveX + waveY;

              gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
          `,
          fragmentShader: `
            uniform sampler2D texture1;
            varying vec2 vUv;

            void main() {
              gl_FragColor = texture2D(texture1, vUv);
            }
          `,
          side: THREE.DoubleSide,
          transparent: true // âœ… Ð¨ÐµÐ¹Ð´ÐµÑ€Ð½Ñ‹Ð¹ Ð¼Ð°Ñ‚ÐµÑ€Ð¸Ð°Ð» Ñ‚Ð¾Ð¶Ðµ Ð´Ð¾Ð»Ð¶ÐµÐ½ Ð±Ñ‹Ñ‚ÑŒ Ð¿Ñ€Ð¾Ð·Ñ€Ð°Ñ‡Ð½Ñ‹Ð¼
        });

        const plane = new THREE.Mesh(geometry, material);

        // ðŸ‘‰ Ð—Ð´ÐµÑÑŒ Ð½Ð°ÑÑ‚Ñ€Ð°Ð¸Ð²Ð°ÐµÑ‚ÑÑ Ð¸Ð·Ð¾Ð¼ÐµÑ‚Ñ€Ð¸Ñ â€” Ð½Ð°ÐºÐ»Ð¾Ð½ ÐºÐ°Ñ€Ñ‚Ð¸Ð½ÐºÐ¸
        plane.rotation.x = -0.8;  // ÐÐ°ÐºÐ»Ð¾Ð½ Ð²Ð¿ÐµÑ€Ñ‘Ð´-Ð½Ð°Ð·Ð°Ð´
        plane.rotation.y = -0.5;  // Ð’Ð»ÐµÐ²Ð¾-Ð²Ð¿Ñ€Ð°Ð²Ð¾
        plane.rotation.z = 0.8;   // ÐŸÐ¾Ð²Ð¾Ñ€Ð¾Ñ‚ Ð¿Ð¾ Ð¿Ð»Ð¾ÑÐºÐ¾ÑÑ‚Ð¸

        scene.add(plane);

        // ðŸ‘‡ ÐœÑÐ³ÐºÐ¸Ðµ Ð¿Ð¾ÐºÐ°Ñ‡Ð¸Ð²Ð°Ð½Ð¸Ñ Ð¾Ñ‚ Ð´Ð²Ð¸Ð¶ÐµÐ½Ð¸Ñ Ð¼Ñ‹ÑˆÐ¸
        document.addEventListener("mousemove", e => {
          const x = (e.clientX / window.innerWidth) - 0.5;
          const y = (e.clientY / window.innerHeight) - 0.5;

          // â— Ð—Ð´ÐµÑÑŒ Ð¼Ð¾Ð¶Ð½Ð¾ Ñ‡ÑƒÑ‚ÑŒ ÑƒÐ¼ÐµÐ½ÑŒÑˆÐ¸Ñ‚ÑŒ Ð²Ð»Ð¸ÑÐ½Ð¸Ðµ Ð¼Ñ‹ÑˆÐ¸, ÐµÑÐ»Ð¸ Ð½ÑƒÐ¶Ð½Ð¾
          plane.rotation.y = -0.5 + x * 0.3;
          plane.rotation.x = -0.8 + y * 0.3;
        });

        // ðŸ” ÐžÑÐ½Ð¾Ð²Ð½Ð¾Ð¹ Ñ†Ð¸ÐºÐ» Ð°Ð½Ð¸Ð¼Ð°Ñ†Ð¸Ð¸
        function animate(time) {
          requestAnimationFrame(animate);
          material.uniforms.time.value = time * 0.001;
          renderer.render(scene, camera);
        }

        animate();
      }
    );

    // ðŸ“ ÐŸÐµÑ€ÐµÑ€Ð°ÑÑ‡Ñ‘Ñ‚ Ð¿Ñ€Ð¸ Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ð¸ Ñ€Ð°Ð·Ð¼ÐµÑ€Ð° Ð¾ÐºÐ½Ð°
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
